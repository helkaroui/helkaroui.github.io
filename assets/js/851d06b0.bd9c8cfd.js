"use strict";(self.webpackChunksharek_dev=self.webpackChunksharek_dev||[]).push([[7317],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return y}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),d=c(n),y=a,m=d["".concat(l,".").concat(y)]||d[y]||p[y]||o;return n?r.createElement(m,i(i({ref:t},s),{},{components:n})):r.createElement(m,i({ref:t},s))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var u={};for(var l in t)hasOwnProperty.call(t,l)&&(u[l]=t[l]);u.originalType=e,u.mdxType="string"==typeof e?e:a,i[1]=u;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2338:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return d}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=n(4996),u=["components"],l={title:"ReduceByKey vs GroupByKey"},c=void 0,s={unversionedId:"spark/optimizations/reducebykey_vs_groupbykey",id:"spark/optimizations/reducebykey_vs_groupbykey",title:"ReduceByKey vs GroupByKey",description:"In this article we are demystifying two known Spark Operators: reduceByKey and groupByKey",source:"@site/notes/big_data_notes/spark/optimizations/reducebykey_vs_groupbykey.mdx",sourceDirName:"spark/optimizations",slug:"/spark/optimizations/reducebykey_vs_groupbykey",permalink:"/big_data/spark/optimizations/reducebykey_vs_groupbykey",draft:!1,tags:[],version:"current",frontMatter:{title:"ReduceByKey vs GroupByKey"},sidebar:"docs",previous:{title:"Quick wins",permalink:"/big_data/spark/optimizations/quick_wins"},next:{title:"Quick Start",permalink:"/big_data/kafka/quick_start"}},p={},d=[{value:"groupByKey",id:"groupbykey",level:2},{value:"reduceByKey",id:"reducebykey",level:2},{value:"When to avoid <code>groupByKey</code> ?",id:"when-to-avoid-groupbykey-",level:2},{value:"When to avoid <code>reduceByKey</code> ?",id:"when-to-avoid-reducebykey-",level:2},{value:"Conclusion",id:"conclusion",level:2}],y={toc:d};function m(e){var t=e.components,n=(0,a.Z)(e,u);return(0,o.kt)("wrapper",(0,r.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this article we are demystifying two known Spark Operators: ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceByKey")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"groupByKey")),(0,o.kt)("h2",{id:"groupbykey"},"groupByKey"),(0,o.kt)("p",null,"Imagine a Dataset distributed in 3 partitions. The dataset consist of a transactional table with in each row the revenue\nof a store located in different countries. We want to sum these revenues at country level."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala",metastring:'title="GroupByKey example"',title:'"GroupByKey','example"':!0},'case class Record(country: String, revenue: Double)\n\nimport spark.implicits._\n\nval ds = Seq(\n    Record("USA", 112),\n    Record("USA", 250),\n    Record("USA", 360),\n    Record("INIDA", 102),\n    Record("INDIA", 205),\n).toDS[Record]\n\nds\n  .groupbByKey(_.country)\n  .mapGroups((country, revenues) => Record(country, revenues.map(_.revenue).sum))\n')),(0,o.kt)("p",null,"a ",(0,o.kt)("inlineCode",{parentName:"p"},"groupByKey")," will start by moving data from original partitions and create a partition per country (aggregation key).\nThen, it will apply the aggregation function (here a ",(0,o.kt)("inlineCode",{parentName:"p"},"sum")," function)."),(0,o.kt)("div",{style:{textAlign:"center"}},(0,o.kt)("img",{alt:"spark reducebykey",src:(0,i.Z)("/img/groupByKeyDiagram.svg")})),(0,o.kt)("p",null,"As shown in the diagram, the data will be repartitioned and thus a shuffle will take place. In real life data is not\nnaturally balanced, so in case where a key is too frequent, it's related data will be put in one partition."),(0,o.kt)("h2",{id:"reducebykey"},"reduceByKey"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"reduceByKey")," will operate in two steps: (1) In each partition it will apply the aggregation function locally\n(2) all the key-value pairs are then shuffled around, send over wire, and finally being reduced to get the final result."),(0,o.kt)("p",null,"Here is the implementation of the same example using reduceByKey :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-scala"},'case class Record(country: String, revenue: Double)\n\nimport spark.implicits._\n\nval ds = Seq(\n    Record("USA", 112),\n    Record("USA", 250),\n    Record("USA", 360),\n    Record("INIDA", 102),\n    Record("INDIA", 205),\n).toDS[Record]\n\nds\n  .rdd\n  .keyBey(_.country)\n  .reduceByKey((r1, r2) => r1.copy(revenue = r1.revenue + r2.revenue ) )\n')),(0,o.kt)("p",null,"Look at the diagram below to understand what happens with reduceByKey. Notice how pairs on the same machine with the\nsame key are combined (by using the lamdba function passed into reduceByKey) before the data is shuffled. And only the\npartial sum results are sent over the wire to be reduced."),(0,o.kt)("div",{style:{textAlign:"center"}},(0,o.kt)("img",{alt:"spark reducebykey",src:(0,i.Z)("/img/reduceByKeyDiagram.svg")})),(0,o.kt)("p",null,"This means we are more likely to have an OOM exception with a groupByKey than a reduceByKey."),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("h3",{parentName:"div",id:"how-oom-exception-occurs-"},"How OOM exception occurs ?"),(0,o.kt)("p",{parentName:"div"},"Spark spills data to disk when there is more data shuffled onto a single executor machine than can fit in memory.\nHowever, it flushes out the data to disk one key at a time - so if a single key has more key-value pairs than can fit\nin memory, an out of memory exception occurs."))),(0,o.kt)("p",null,"While both of these functions will produce the correct answer, the reduceByKey example works much better on a large\ndataset. That's because Spark knows it can combine output with a common key on each partition before shuffling the data."),(0,o.kt)("h2",{id:"when-to-avoid-groupbykey-"},"When to avoid ",(0,o.kt)("inlineCode",{parentName:"h2"},"groupByKey")," ?"),(0,o.kt)("p",null,"You can imagine that for a much larger dataset size, the difference in the amount of data you are shuffling becomes\nmore exaggerated and different between reduceByKey and groupByKey. Here are some rules when to avoid a ",(0,o.kt)("inlineCode",{parentName:"p"},"groupByKey")," :"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When returning a type different from your input value type. You would like to favor a ",(0,o.kt)("inlineCode",{parentName:"li"},"combineByKey")," in this case."),(0,o.kt)("li",{parentName:"ul"},"When merging the values for each key using an associative function. You would like to use a ",(0,o.kt)("inlineCode",{parentName:"li"},"foldByKey")," operator.")),(0,o.kt)("h2",{id:"when-to-avoid-reducebykey-"},"When to avoid ",(0,o.kt)("inlineCode",{parentName:"h2"},"reduceByKey")," ?"),(0,o.kt)("p",null,"This operator is only available with RDD API, thus switching from typed dataset to rdd and back, induces performance\nreduction due to java serialization."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Choosing the right operator can be tricky the first time, but can help to optimize long-running jobs quickly."))}m.isMDXComponent=!0}}]);